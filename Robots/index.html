<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Remco Tukker &mdash; Robots</title>
    <meta name="description" content="My attempts at building robots">
    <!-- main styles-->
    <link href="/static/css/styles.css" rel="stylesheet">
    <script src="/static/js/jquery-2.1.1.js"></script>
    <script src="/static/js/vis.js"></script>
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Neuton:300">
    <link href="http://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet" type="text/css">
    <!-- alternative: allegreya and lato-->
  </head>
  <body><svg version="1.1" baseProfile="full" width="400" height="600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 600" preserveAspectRatio="xMidYMid" id="svggraph" style="overflow: hidden;">
       
  <defs>
      <!-- gradient for the text ellipses -->
      <radialGradient id="gradient1" >
        <stop offset="0%" stop-color="white" stop-opacity="1" />
        <stop offset="50%" stop-color="white" stop-opacity="1" />
        <stop offset="100%" stop-color="white" stop-opacity="0" />
      </radialGradient>

      <!-- mask with gradient for the fading at the edges.. -->
      <radialGradient id="Gradient" >
        <stop offset="0" stop-color="white" />  
        <stop offset="0.7" stop-color="white" />
        <stop offset="1" stop-color="black" />
      </radialGradient>
      <mask id="Mask" draggable="false">   
        <rect x="0" y="0" width="100%" height="100%" fill="url(#Gradient)" />
      </mask>

  </defs>
  
  <!-- Nasty thing is that we dont define the font here, but in CSS. 
       Consequences: 
         when rendering it outside the website, we have to include the font
         we shouldnt change the font without changing the sizes here, or it will look borked       
   -->
  <g mask="url(#Mask)" >
   <g id="svgpanzoom" transform="matrix(1,0,0,1,200,300)" >
    <!-- all items should go in here, and then we can dynamically change the translate and the scale to pan and zoom -->
    
    <!-- <line x1="10" x2="50" y1="110" y2="150" stroke="white" stroke-width="3"/> -->
    <g id="g0" class="graphnode" transform="translate(100,50)" >    
      <ellipse id="e1" cx="0" cy="0" rx="45" ry="45" fill="url(#gradient1)" /> 
      <a xlink:href="/AboutWebsite/"> <text x="0" y="5" text-anchor="middle">About Website</text> </a>
    </g>
    <g id="g1" class="graphnode" transform="translate(140,50)" >    
      <ellipse id="e1" cx="0" cy="0" rx="45" ry="45" fill="url(#gradient1)" /> 
      <a xlink:href="/SVGPanZoom/"> <text x="0" y="5" text-anchor="middle">SVG Pan Zoom</text> </a>
    </g>
    <g id="g2" class="graphnode" transform="translate(10,10)" >    
      <ellipse id="e2" cx="0" cy="0" rx="45" ry="45" fill="url(#gradient1)" />
      <a xlink:href="/Robots/"> <text x="0" y="5" text-anchor="middle">Robots</text> </a>
    </g>
    <g id="g3" class="graphnode" transform="translate(40,90)" >    
      <ellipse id="e3" cx="0" cy="0" rx="45" ry="45" fill="url(#gradient1)" />
      <a xlink:href="/AboutMe/"> <text x="0" y="5" text-anchor="middle">About Me</text> </a>
    </g>

    <!-- TODO also add some nice edges to the graph -->
   </g>
  </g>


  <script type="text/javascript"><![CDATA[

// TODO we can move this code to a separate repo as well :-)
var addAnimationToGraph = function(config) {

    var defaultConfig = {
        svgID: "svg",             // ID of the svg element that should catch mouse clicks and touches
    }
    config = config || {};
    for (var key in defaultConfig) if (typeof config[key] == "undefined") config[key] = defaultConfig[key];

    // our reference to the svg that contains the nodes
    var svg = document.getElementById(config.svgID);       

    // variables for dragging nodes 
    var dragging = null;           // this will contain a reference to the node that is being dragged
    var previousx, previousy;      // previous x and y coordinates


    // first read the existing graph 
    // create an object with references to all our existing graph nodes
    nodeElements = svg.getElementsByClassName('graphnode');
    var nodes = {};
    var nodeNrs = {};
    for (var i = 0; i < nodeElements.length; i++) {
        var TF = nodeElements[i].getAttribute("transform");  
        var x = parseFloat(TF.substring(TF.indexOf("(") + 1));   // TODO use neater method from panzoom code for handling TFs
        var y = parseFloat(TF.substring((TF.lastIndexOf(",") + 1 ) || (TF.lastIndexOf(" ") + 1 ) ));
        nodes[nodeElements[i].id] = {x:x, y:y, edges:[]}; // TODO edges to be added later
        nodeNrs[nodeElements[i].id] = i; // for later reference
    }
    // TODO also read edge elements from the svg


    // instantiate physics worker
    var physicsWorker = new Worker("/static/js/physics.js");  
    // TODO: make this a data URI
    // TODO: allow for overriding the default config of the physics worker from here

    // sending and receiving messages from the worker
    physicsWorker.addEventListener("message", function (evt) {
      for (var i in evt.data) {
        if (dragging != null && dragging.id == i) continue; // dont update position of a node that we are currently dragging

        var node = nodeElements[nodeNrs[i]]; // look up the node thats associated with this ID

        var oldTF = node.getAttribute("transform");
        var oldx = parseFloat(oldTF.substring(oldTF.indexOf("(") + 1));
        var oldy = parseFloat(oldTF.substring((oldTF.lastIndexOf(",") + 1 ) || (oldTF.lastIndexOf(" ") + 1 ) ));
        node.setAttribute("transform", "translate(" + (oldx + evt.data[i].dx) + "," + (oldy + evt.data[i].dy) + ")"); //TODO use neater method from panzoom code for updating transforms
      }
    });

    function updatePhysicsWorkerWhenDraggingNode(nodeId, x, y, oldx, oldy) {
      // send the current info of node with id nodeId to the physicsworker (x, y and maybe also do the xold and yold)
      var msg = {};
      msg[nodeId] = {x:x, y:y, xold: oldx, yold: oldy};
      physicsWorker.postMessage(msg);
    }


    // update the node info in the worker in the following way:
    // {"node1":{mass:1, x:30, y:40, edges:["node2", ... ]}, "node2":{...}}
    // nodes or properties that are not mentioned are assumed unchanged; remove a node by putting its mass to 0
    // nodes are added when they are mentioned with default mass 1 and default location at the origin
    //var testgraph = {"1":{edges:["2","3"]}, "2":{edges:["1"]}, "3":{edges:["1"]}};
    physicsWorker.postMessage(nodes); 
    physicsWorker.postMessage("start"); // start the worker.
    //physicsWorker.postMessage("stop"); // pause the worker.

    // TODO expose starting / stopping animation as an interface of this module


    // code for dragging of nodes
    function nodeMouseDown(evt) {
      // find out if its a mouse down on a graphnode (we may get ellipse in the group here or the text inside the ahref inside the group)
      //  ... yes, the following is fragile... dont do any extra nesting in the graphnode for now; TODO: improve, search upwards till you either found a graphnode or reached top of svg
      if (evt.target.parentNode.className.baseVal != "graphnode") return; // && evt.target.parentNode.parentNode.className.baseVal != "graphnode") return;

      evt.stopPropagation(); // if youre touching a node, we dont want to pan the image at the same time
      
      // if (evt.target.tagName.toLowerCase() != "ellipse") return; // only drag the node when you touch the ellipse (not the text/hyperlink)
      if (evt.target.tagName.toLowerCase() == "text") return; // dont interfere with hyperlink dragging
     
      dragging = evt.target.parentNode;
      previousx = evt.clientX;
      previousy = evt.clientY;
      
      return false;
    }

    // Convert screen-based coordinates (eg from mouse events) into the panzoom coordinate system
    function screenToPanZoomCoords(x, y) {
      var pt = svg.ownerSVGElement.createSVGPoint();  // TODO use ownerSVGElement properly, also in the panzoom code to fix bug if svgID is not the actual svg
      pt.x = x;
      pt.y = y;
      return pt.matrixTransform(svg.getScreenCTM().inverse());
    }

    function nodeMouseMove(evt) {
      if (!dragging) return;
      var oldPt = screenToPanZoomCoords(previousx, previousy);
      var newPt = screenToPanZoomCoords(evt.clientX, evt.clientY);
      var dx = newPt.x - oldPt.x;
      var dy = newPt.y - oldPt.y;
      previousx = evt.clientX;
      previousy = evt.clientY;

      // parse the existing transform and add the dx / dy
      var oldTF = dragging.getAttribute("transform");
      var oldx = parseFloat(oldTF.substring(oldTF.indexOf("(") + 1));
      var oldy = parseFloat(oldTF.substring((oldTF.lastIndexOf(",") + 1 ) || (oldTF.lastIndexOf(" ") + 1 ) )); // TODO use new fancy code from panzoom

      dragging.setAttribute("transform", "translate(" + (oldx + dx) + "," + (oldy + dy) + ")");
      updatePhysicsWorkerWhenDraggingNode(dragging.id, oldx + dx, oldy + dy, oldx, oldy);
      return false;
    }

    function nodeMouseUp(evt) {
      dragging = null;
    }

    function nodeDragStart(evt) {
      if (evt.target.parentNode.className.baseVal != "graphnode") return; // TODO: improve, just as above
      evt.stopPropagation();
       // we may get "a" here for a link or "ellipse" or other stuff of course..
      if (evt.target.tagName.toLowerCase() == "a") return; // dont interfere with hyperlink dragging
      evt.preventDefault(); // but otherwise, dont even think about dragging my elements!
    }

    // adding the event listeners
    svg.addEventListener('mousedown', nodeMouseDown );
    svg.addEventListener('mousemove', nodeMouseMove );
    svg.addEventListener('dragstart', nodeDragStart ); 
    svg.addEventListener('mouseup', nodeMouseUp );
    svg.addEventListener('dragend', nodeMouseUp );   // to stop node from being captured after dragging hyperlink
    svg.addEventListener('mouseleave', nodeMouseUp ); 

    // TODO also add touch events, just like with panzoom code
};

addAnimationToGraph({svgID: "svgpanzoom"});


// TODO get this from github repo when building this svg
// adding pan/zoom interaction to the graph
var addPanZoomToSVG = function(config) {

    /* ===== take care of config =====                                             */

    var defaultConfig = {
        svgID: "svg",             // ID of the svg element that should catch mouse clicks and touches
        panzoomID: "panzoom",     // ID of the element that should be panzoomed
        scrollSpeed: 5,         // Speed of scroll zooming
        pinchSpeed: 1,          // Speed of pinch zooming (5 times smaller than scrollSpeed is an ok choice)
        upOnMouseOut: false     // treat mouse leaving svg area as a mouseup event
    }
    config = config || {};
    for (var key in defaultConfig) if (typeof config[key] == "undefined") config[key] = defaultConfig[key];

    // set up the panzoom transform we're going to use
    var svg = document.getElementById(config.svgID);       
    var panzoom = document.getElementById(config.panzoomID); 
    panzoom.transform.baseVal.appendItem(panzoom.transform.baseVal.createSVGTransformFromMatrix(svg.createSVGMatrix()));
    var tf = panzoom.transform.baseVal.getItem(panzoom.transform.baseVal.numberOfItems - 1);
    var tfMatrix = tf.matrix;

    // mouse and touches state; this object will hold all the locations of touches / mouse, accessed by a touch ID
    var ongoingTouches = {};


    /* ===== functions for panning and zooming =====                               */

    // Convert screen-based coordinates (eg from mouse events) into the panzoom coordinate system
    function screenToPanZoomCoords(x, y) {
      var pt = svg.createSVGPoint();
      pt.x = x;
      pt.y = y;
      return pt.matrixTransform(panzoom.getScreenCTM().inverse());
    }

    // pan the image a certain distance (from screen coords to screen coords)
    function pan(xold, yold, xnew, ynew) {
      var pt1 = screenToPanZoomCoords(xold, yold); // to make sure we always use the newest transform
      var pt2 = screenToPanZoomCoords(xnew, ynew);
      tfMatrix = tfMatrix.translate(pt2.x - pt1.x, pt2.y - pt1.y);
      tf.setMatrix(tfMatrix);
    }

    // zoom the image at a certain x y location (in screen coordinates)
    function zoom(x, y, factor) {  
      var pt = screenToPanZoomCoords(x, y);
      tfMatrix = tfMatrix.translate(pt.x, pt.y).scale(factor).translate(-pt.x, -pt.y); // first translate x and y to origin, then zoom, then translate origin back to x y
      tf.setMatrix(tfMatrix);
    }


    /* ===== functions for handling of events =====                                */

    // Calculate average point of ongoingTouches and the total distance from that point to touches; ongoingTouches must not be empty! 
    function touchLocationAndRadius() { 
      var x = 0, y = 0, rsquared = 0;
      for (var key in ongoingTouches) {
          x += ongoingTouches[key].x;
          y += ongoingTouches[key].y;
      }
      x /= Object.keys(ongoingTouches).length; y /= Object.keys(ongoingTouches).length;
      for (var key in ongoingTouches) rsquared += (ongoingTouches[key].x - x) * (ongoingTouches[key].x - x) + (ongoingTouches[key].y - y) * (ongoingTouches[key].y - y);
      return {x: x, y: y, rsquared: rsquared};
    }

    // mousedown / touchstart handling: add item to ongoingTouches object
    function down(evt) {
      if (!evt.changedTouches) evt.changedTouches = [{identifier: "mouse", clientX: evt.clientX, clientY: evt.clientY}]; // make mouse event look like touch event
      for (var i=0; i < evt.changedTouches.length; i++) ongoingTouches[evt.changedTouches[i].identifier] = {x: evt.changedTouches[i].clientX, y: evt.changedTouches[i].clientY};
    }

    // mousemove / touchmove handling
    function move(evt) {

      var touchIds = Object.keys(ongoingTouches);
      if (touchIds.length == 0) return;  // no touches going on / mouse not pressed
      evt.preventDefault();              // no scrolling of whole webpage with fingers

      if (!evt.changedTouches) evt.changedTouches = [{identifier: "mouse", clientX: evt.clientX, clientY: evt.clientY}]; // make mouse look like finger

      if (touchIds.length == 1) {   // just one finger or mouse => do panning
        pan(ongoingTouches[touchIds[0]].x, ongoingTouches[touchIds[0]].y, evt.changedTouches[0].clientX, evt.changedTouches[0].clientY);
        ongoingTouches[touchIds[0]].x = evt.changedTouches[0].clientX; // update touch info
        ongoingTouches[touchIds[0]].y = evt.changedTouches[0].clientY;  

      } else {                      // multiple fingers => do panning and zooming
        var oldGesture = touchLocationAndRadius();            // get old location and radius
        for (var i=0; i < evt.changedTouches.length; i++) {   // update touch info
          ongoingTouches[evt.changedTouches[i].identifier].x = evt.changedTouches[i].clientX;
          ongoingTouches[evt.changedTouches[i].identifier].y = evt.changedTouches[i].clientY;
        } 
        var newGesture = touchLocationAndRadius();            // get new location and radius

        pan(oldGesture.x, oldGesture.y, newGesture.x, newGesture.y);               // first handle any panning
        var z = Math.pow(newGesture.rsquared / oldGesture.rsquared, config.pinchSpeed);   // find out how much we want to zoom
        zoom(newGesture.x, newGesture.y, z);                                       // and then zoom in

      }
    }

    // mousewheel handling
    function wheel(evt) {
      var z = 1 + (0.01 * evt.deltaY / Math.abs(evt.deltaY)) * config.scrollSpeed;         // calculate how much we want to scale
                                // the Math.abs is to deal with some nasty browser differences in deltaY numbers
      zoom(evt.clientX, evt.clientY, z);                                                // and then zoom in
      evt.preventDefault();                                                             // prevent scrolling of page
    }

    // mouseup / touchend handling
    function up(evt) {
      if (!evt.changedTouches) evt.changedTouches = [{identifier: "mouse"}];            // make mouse look like touch
      for (var i=0; i < evt.changedTouches.length; i++) delete ongoingTouches[evt.changedTouches[i].identifier]; 
    }


    /* ===== registering event handlers =====                                      */

    svg.addEventListener('mousedown', down);
    svg.addEventListener('touchstart', down);
    svg.addEventListener('mouseup', up);
    svg.addEventListener('touchend', up);
    svg.addEventListener('touchcancel', up);
    svg.addEventListener('mouseleave', function(evt){ if (config.upOnMouseOut) return up(evt); }); 
    svg.addEventListener('mousemove', move);
    svg.addEventListener('touchmove', move);
    // The "wheel" event is rather new, see if it works on some older browsers (IE9 comes to mind..)
    svg.addEventListener('wheel', wheel);

    svg.addEventListener('dragstart', function(evt) {evt.preventDefault(); }); // no dragging away svg elements please
    svg.addEventListener('dragend', up); // in case some elements of the svg are in fact allowed to be dragged, prevent panning at dragend

};

addPanZoomToSVG({svgID: "svggraph", panzoomID: "svgpanzoom"});

  ]]></script>



</svg>

    <div id="maincontainer">
      <div id="sidebarcontainer"><a href="/" id="navigationlink"></a>
      </div>
      <div id="contentwrapper">
        <div id="toppadding"></div>
        <div id="contentcontainer"><h1 id="robots">Robots</h1>
<h2 id="stiltbot-hypothetical-">Stiltbot (hypothetical)</h2>
<h3 id="materials">Materials</h3>
<ul>
<li>Two old bicycle spokes and spoke nipples</li>
<li>Three HXT900-like servos, modified to give access to the potmeter value</li>
<li>Small version of an Arduino or other uController</li>
<li>Accelerometer</li>
<li>Battery (eg 3S LiPo) and a BEC that converts battery power to 5 to 6 V, at least 1A</li>
<li>Some small pieces of wood or other mounting material</li>
</ul>
<h3 id="description">Description</h3>
<p>While working on the Ostrichbot I noticed that the mounting holes of a HXT900-like microservo are exactly the right size for an old bicycle spoke (yeah, I&#39;m Dutch). This solved one of my construction problems, namely how to create a slightly flexible, but still sturdy leg for a robot, and gave me the idea for a simplified Ostrichbot. Here are photos of Stiltbots compliant leg:</p>
<p><img class="normalimage" src="leg.jpg" alt="Stiltbot leg" title="Stiltbot leg"></p>

<p><img class="normalimage" src="knee.jpg" alt="Mounting of spoke to servo" title="Mounting of spoke to servo"></p>

<p>I bent the spoke so that it fits through the two mounting holes exactly, and the screw thread in the right position to fasten it at one of the mounting holes with the matching spoke nipple. If you want to do this yourself, use steel spokes and make sure you have the right spoke diameter (there&#39;s three standard diameters, don&#39;t know which one I used at the moment). This gives a quite nice compliant foot for robots of 100 to 500 grams (guesstimate). Of course, you can also bent the lower end of the spoke into a shape that gives you a larger support surface.</p>
<p>So, how to make a Stiltbot now? Use a bit of the mounting material to connect the servo horns on the leg servos, and also connect the last servo that will be used for right-left balance. All the rest of the material, battery, accelero, BEC and uController will go on another piece of mounting material that is connected to the balance servo horn (see drawing). Ideally, this shouldn&#39;t be too heavy, I was thinking around 100g only.</p>
<p><img class="normalimage" src="stiltbot_frame.jpg" alt="Drawing of Stiltbot construction" title="Drawing of Stiltbot construction"></p>

<p>Wire everything up, write some software, and that&#39;s all! Well... Of course, the reason that this is a hypothetical bot and not a real bot is that the &quot;write some software&quot; part is rather hard. As you may have noticed, we dont have a foot on our leg or even an &quot;ankle&quot; actuator, which means we can only balance the robot by moving the &quot;hip&quot; actuator and changing the angle between the body and the leg. This is a situation that is studied extensively with the so-called <a href="http://www.cc.gatech.edu/projects/acrobot/">Acrobot</a>. So, luckely, at least it is theoretically possible to balance this robot. </p>
<p>In practice however, we have to admit that the stiltbot is actually three connected Acrobots instead of just one: one for each leg and one for left-right balance. That means that to build the control software that can balance the robot we either need to do <em>a lot</em> of parameter tuning, or we have to build a computer model of the robot, taking into account all flexible parts, noise issues, etc (and probably both). I think this would require at least a couple of months if you want to implement balancing, walking, turning, and maybe even running, so until I can find that time, this robot remains hypothetical.</p>
<h3 id="relevant-links">Relevant links</h3>
<ul>
<li>Paper about Acrobot control: <a href="http://www2.ece.ohio-state.edu/~passino/PapersToPost/acrobot-JIRSTA.pdf">SC Brown &amp; KM Passino: Intelligent Control for an Acrobot</a></li>
<li>Acrobot swinging up and balancing: <a href="https://www.youtube.com/watch?v=FeCwtvrD76I">MIT Robot Locomotion Group on Youtube</a></li>
<li>Simple hack for a hobby servo to give position feedback: <a href="http://forums.trossenrobotics.com/tutorials/how-to-diy-128/get-position-feedback-from-a-standard-hobby-servo-3279/">Trossen Robotics Community</a></li>
</ul>
<h2 id="ostrichbot">Ostrichbot</h2>
<h3 id="materials">Materials</h3>
<ul>
<li>Two old bicycle spokes and spoke nipples</li>
<li>6 to 8 HXT900-like servos, some of them modified to give access to the potmeter value</li>
<li>Small version of an Arduino or other uController</li>
<li>Accelerometer</li>
<li>Battery (eg 3S LiPo) and a BEC that converts battery power to 5 to 6 V, at least 2A</li>
<li>Some small pieces of wood or other mounting material</li>
</ul>
<h3 id="description">Description</h3>
<p>I&#39;m currently working on this robot. It&#39;s a robot inspired by running birds, and I would like it to be a very light, small and cheap robot that nevertheless has full bipedal mobility: I want it to stand, walk, run, turn and get up in case it falls. All that with 6 to 8 servos. The feet (lower part of the leg of a bird is what is our foot) will be very similar to the stiltbot leg, except that it will have a foot to make my life a bit easier. The Ostrichbot leg will have an upper part as well. Then in the knee/hip joint there will be some more servos for pointing the leg in the right direction.</p>
<h3 id="relevant-links">Relevant links</h3>
<ul>
<li>Great video material of running ostrich: <a href="http://mfll-uwa.jonasrubenson.com/Comparative.html">University of Western Australia Muscle Function and Locomotion Lab</a></li>
<li>Some inspiration: <a href="https://www.youtube.com/watch?v=vHjVV7AWaGM">MIT Leg Lab Robots on Youtube</a></li>
</ul>
<h2 id="dotty">Dotty</h2>
<p>Worked on this robot when I was employed at DoBots, search <a href="http://www.dobots.nl">their website</a> for more info.</p>

        </div>
        <div id="bottompadding"></div>
      </div>
    </div>
    <!-- main javascript-->
    <script src="/static/js/navigation.js"></script>
    <!--script.-->
    <!-- google analytics code, etc...-->
  </body>
</html>