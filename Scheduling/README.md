# Scheduling

Scheduling is a common problem in many organizations and therefore an important part of Operations Research. One can think about scheduling personnel in hospitals, scheduling jobs in a manufacturing plant, or scheduling classes at a school. For this article I will take the perspective of scheduling classes, because I have some anecdotal evidence that many schools are using horrible software and that there's lots of room for improvement (note that there is some good software available already though). Factories are actually using horrible software too, but their scheduling problems show more variety, making it harder to work on scheduling for factories in general; each factory can benefit from specific scheduling strategies, while it is easier to find a scheduling method that can work for most schools.

## NP-Hardness and approximation

Scheduling is in general not a particularly easy task. Even in ideal cases without any nasty exceptions, the task is usually [NP-Hard](http://en.wikipedia.org/wiki/NP-hard), meaning that the time it takes to find the best schedule grows exponentially with the size of the problem. In practice, this means that it may take seconds to find a schedule for just one week of school, while it may take months or even longer to find a schedule for a whole year. One solution is obviously to make a schedule in which each week is almost the same, as happens on many schools. However, not all schools work that way, sometimes resulting in a lot of manual effort to create the schedule or running computer programs for very long times (eg a week to create an initial schedule and no opportunity to automatically process changes in availability of teachers). 

So, finding the best schedule is something we simply cannot do in some situations. However, in many cases it is not even clear what the "best" schedule would be. Classes that don't have gaps in their schedules? In general, yes, but one or two small gaps in a week won't harm the students, in fact, it may be used to work together on homework or make new friends. Teachers that have their own classroom? Well, maybe, but for classes that are on the large side, it may be better to change to a larger classroom. In any real-world schedule there are many of such tradeoffs based on "soft constraints" that are not exactly quantifiable. This means that we are actually not even looking for the best schedule: we are looking for a good schedule that is ideally close to the best schedule, but above all reasonable and can not be improved upon in an obvious way (think of all the classes begging their teachers to move the class to another time...).

Thus, we enter into the rather recent research area of [approximation methods](http://en.wikipedia.org/wiki/Approximation_algorithm) for NP-Hard problems. As it turns out, NP-Hard problems show a lot of variety in how easy or hard it is to find an approximate solution: a solution that is within a fixed percentage of the best solution. Some NP-Hard problems can surprisingly be approximated extremely well, such as the Euclidian travelling salesman problem: it is possible to find solutions almost arbitrarely close to the ideal solution without the computational costs growing exponentially with the problem size. Approximation algorithms are an active research area, and for many problems a good approximation algorithm is not yet known (or even unknown whether such an algorithm can exist). Broadly speaking, at the moment you're in luck if you can "relax" your scheduling problem (an Integer Programming problem) into a so called Linear Program<sup>1</sup>. 

Well, you probably guessed that _in general_, we cannot describe our scheduling problem as such a Linear Program, because it is often not possible to describe our constraints with linear functions. Luckily, we still have a last resort: heuristics. Heuristics are simply a set of methods that will help you find a "reasonable" solution (in general without any guarantees about being within a certain percentage of the best solution, as with approximation algorithms) in a "reasonable" time (sometimes with guarantees on running time, sometimes not). Heuristics have traditionally been the answer to any problems that couldn't be solved exactly and there's a lot of different methods available. To stay with application of scheduling classes: when it's humans that are scheduling, they are using a heuristic. They don't find every possible schedule and compare scores for each of them; instead, they first create a possible schedule and then try to improve on it by swapping stuff. For example, the rule "schedule the most difficult thing first" is a heuristic. In some special cases, a heuristic has in fact been shown to be equivalent to an approximation algorithm, but don't expect to be so lucky when using one!

Thus, if we want to build an automatic scheduling system, we have a couple of questions to answer. First of all, find out how hard your problem is. In case you're sure your problem is always small and you're not in a hurry, just search for all possible solutions and pick the best one<sup>2</sup>. If there's not enough time to do so, make sure you make a strict definition of your problem including any possible exceptions. If there's no exceptions and your problem definition matches one of the problems that have a good approximation algorithm, you're in luck. When no approximation algorithm is available, keep your problem definition in mind and try to find an appropriate heuristic.

## Heuristics

Heuristics that are used to find solutions to NP-Hard problems can actually do only one thing: guide our search. Thus, heuristics are actually some knowledge about the problem in the form of a rule. That knowledge can either be gathered from similar problems that have been solved before (eg, almost all scheduling problems at schools have a solution with some specific properties), or from the problem itself over the time it takes to solve it (eg "I've tried this solution before and it was bad", which is used in "Tabu Search" for example). Ideally, you use both types of knowledge, the first mainly to guide your search in the beginning, the second mainly to guide your search at the end. Note that those two types of knowledge roughly correspond to respectively heuristics and what is often called a "meta-heuristic", but in my opinion using those two words is not particularly helpful. Now, let's see what has been used for scheduling so far.

First of all, two _local search_ methods (local search simply means that we make small steps in the solution space; see for a comprehensive overview [Di Gaspero: Local Search Techniques for Scheduling Problems: Algorithms and Software Tools](http://www.diegm.uniud.it/schaerf/SAS/articoli/PhDThesisLucaDiGaspero.pdf)):

* Simulated Annealing: at first, randomly change stuff, but slowly reduce the chance of changing into a worse schedule. Easy to parallelize and should give very good results, on the condition that there's some slack in the nr of rooms, and occupied hours of teachers and classes, because otherwise it may be impossible to move from one schedule to another by swapping classes. It's possible to fix that by adding dummy hours and rooms with a rather high associated cost, but you risk ending up with a schedule that depends on those.

* Tabu search: Simply put, keep a list of visited solutions and dont visit them again. In it's basic form not very useful or powerful, but the principle is sound and if a more sophisticated version is used it can be helpful. Seems to be used quite a bit in Operations Research for some reason?

Then, two nature-inspired methods that are similar to local search:

* Genetic Algorithms (GA): give no guarantees whatsoever, although it usually should find an okay schedule and is easy to parallelize. Parameters of the algorithm would have to be tweaked in a non-obvious way for each significant change in the problem description to ensure performance doesnt detoriate. Don't think this is a very good method. Mutation of the gene sequence corresponds to local search, but crossovers in the gene sequence give a large jump in the search space.

* Particle Swarm Optimization (PSO): Multiple solutions are maintained simultaneously and iteratively updated according to some rules. Probably better suited to the problem than GA because parameters of PSO are more straightforward. Not local search simply because there's multiple solutions maintained, but each of them does in fact do a local search.

From the multi-agent crowd we get:

* Market-based methods: a market mechanism is used to guide the search. In case of scheduling, one could for example introduce a price for getting a teacher to teach at a specific moment, and let each class bid on the teachers that they need in some sort of auction. An advantage of using an agent-based method is that it is very simple to map responsibilities and functions from the real world to the software. An advantage of a market-based method can be that it is possible to match the scheduling economy with the real economy in order to introduce a very clear monetary measure to choose between alternative schedules. Unfortunately, it's not easy (or maybe even possible) to dream up such a market in all situations and I couldn't come up with a suitable mechanism for our school scheduling usecase. See [Walsh, Wellman, Wurman & MacKie Mason: Some economics of market-based distributed scheduling, 1997](http://pdf.aminer.org/000/297/839/some_economics_of_market_based_distributed_scheduling.pdf) for some basic insights in this approach, and for an example of a market mechanism in action see [Lee, Kumara & Chatterjee: Multiagent based dynamic resource scheduling for distributed multiple projects using a market mechanism, 2003](ftp://66.214.186.239/Seagate%20Slim%20Drive/HDD/_Transfer/Lilit_7.4.2013/Archive_2009/AUA/AuADocs/Thesis_fromAUAfolder/Thesis%20documents/Theory/docs/resource%20shceduling%20for%20multiple%20projects.pdf)

I came up with one proposal for a scheduling heuristic myself, but as it turns out a similar algorithm is used by [FET](http://lalescu.ro/liviu/fet/) already since 2007 and they give a reference to Marte 2002:

* Recursive swapping: while scheduling for a school, there are some constraints that are pretty hard, in particular the requirement that groups of students get a particular number of hours for each class (the teacher is often the same for all of these hours, but not necessarily). We can use this to guide our search, because it means that we can search for combinations of swaps that still fulfill this constraint and improve the schedule. In FET, this is used in the following procedure: when adding a class, find the timeslot with minimal conflicts and place it there, while removing the conflicting courses (swapping in the new course for the conflicting courses). Then try to allocate the conflicting courses to some other time in the same way, and so on, and so on (the FET website has a better description). I would change it a little bit by starting with an existing schedule and search for combinations of swaps that give most benefit (eg by adding an objective function for each class and teacher), but it may well be that the FET implementation is much better. As far as I (and the FET authors) can see, this method matches one of the methods used by human schedulers (and that's also how I came up with this idea). This is an important benefit, because even if the resulting schedule is far from optimal, if a human cannot see how to improve it, it will definetely be considered good enough!

As mentioned before, heuristics give the best result if you know that the problem has certain structure and your heuristics are tuned to exploit that structure. Any remaining structure, about which you can not make assumptions, should also be picked up, during the browsing through the solution space. In the case of scheduling classes, a reasonable a priori assumption could for example be that the soft constraints in the problem are only dependent on individual classes or teachers. It will not always be true, but I think there are only few exceptions. Theoretically, that structure can be exploited to improve our searching strategy, but in this case I did not find the proper way to do so!

## Real time updates

Of course, once a schedule is made, it is not fixed. Teachers get sick, classes get cancelled, tests have to be rescheduled, etc. This means we actually have a _dynamic scheduling_ problem that should be dealt with by an _online_ algorithm. However, as there's not too many changes in the schedule, most algorithms will easily be adapted. It just means we have to keep the solution and possibly other information stored. Then, when a change comes in, the algorithm should be able to load the old schedule, make the change, and solve any conflicts that were caused by the change. Ideally, this whole process, and informing all the affected parties, can be done automatically. Human supervision is necessary though, because the computer will not know in which cases it is eg better to cancel a class compared to reschedule a class including possible changes for other classes. In such situations, the algorithm can present the alternatives and let the decision be made by the responsible administrator. For an (unfortunately rather old) overview of dynamic algorithms in general, see [Waldemar Kocjan: Dynamic Scheduling - State of the Art Report, 2002](http://soda.swedish-ict.se/2278/1/SICS-T--2002-28--SE.pdf).

## Follow-up? Maybe...

There seems to be some commercial opportunity for new scheduling programs for schools, even though the market is quite crowded already. It's possible to compete in price with enough volume, and otherwise in performance, in features and in user friendliness. The best way to go about this would be to build a good UI around FET and market it appropriately, including a way to easily adapt the objective function by the users themselves (eg by using JavaScript). However, before doing so there's some market research work left, in particular to find out which software packages schools are using now, including, of course, how much they cost and what could be improved from the school's perspective. Also note that integration with existing systems would be the trickiest requirement; important to choose the right systems to integrate with in the beginning and only later add more (FET already provides some basic integration features).

## Footnotes

<sup>1</sup> The details are quite technical, but it comes down to first relaxing your Integer Programming problem into a Linear Programming problem, which can be solver very efficiently. Then, the LP solution is rounded to an integer solution in a random way, for which the [Lovasz Local Lemma](http://en.wikipedia.org/wiki/Lov%C3%A1sz_local_lemma) is very important. One interesting approach is to see your scheduling problem as an edge coloring problem in a bipartite graph, with part of the nodes representing classes and the other part teachers, edges representing the required classes, and each edge color representing a timeslot. The edge coloring can in turn be modeled as a Multi-Commodity Flow problem (described by [Caragiannis, Ferreira, Kaklamanis, Perennes, Persiano, Rivano: Approximate Constrained Bipartite Edge Coloring, 2001](http://www.researchgate.net/publication/225491580_Approximate_Constrained_Bipartite_Edge_Coloring/file/9fcfd50ae47e60aa32.pdf)) which has good approximation algorithms using above method. In some cases this method may be useful, but I think it is too inflexible in many cases. Check out the excellent book "Design of Approximation Algorithms" if you want to learn more about approximation algorithms (link below).

<sup>2</sup> In Operations Research this is often known as Constraint Programming, which is just a fancy name for trying out all possible solutions. The trick is to know beforehand which solutions are actually possible according to the constraints and to make as many shortcuts in the search as possible.

## Links

* [Michael Marte: Models And Algorithms For School Timetabling - A Constraint Programming Approach, 5 July 2002](http://www.en.pms.ifi.lmu.de/publications/dissertationen/PMS-DISS-2003-1/PMS-DISS-2003-1.pdf)
* [Practice and Theory of Automated Timetabling 2014 Proceedings](http://www.patatconference.org/patat2014/proceedings.html) Papers describing the state of the art in timetabling.
* [The Design of Approximation Algorithms](http://www.designofapproxalgs.com/book.pdf) A whole book, written very recently in 2010 / 2011, about approximation algorithms and their design. Extremely useful and well-written as well. Scheduling is not investigated too much, mainly because scheduling can so far only be approximated in some very specific cases.
* [DMOZ list of scheduling utilities](http://www.dmoz.org/Computers/Software/Educational/Administration_and_School_Management/Scheduling_Utilities/)

A couple of open source scheduling programs that include automatic scheduling:

* [FET](http://lalescu.ro/liviu/fet/) GPL licensed scheduling software for schools that claims to schedule anything within 6k teachers and 30k student groups within 20 minutes.
* [UniTime](http://www.unitime.org) GPL licensed scheduling software based on a Phd thesis that describes the constraint solver, which is supposedly very powerful.
* [Tablix](http://www.tablix.org) GPL licensed scheduling software using a genetic algorithm.

A couple of apparently better known commercial scheduling programs for schools that include automatic scheduling:

* [ascTimeTables](http://www.asctimetables.com) 400 euro and upwards. Only doing schedules for education. Looks quite modern.
* [PrimeTable](http://www.primetimetable.com) 250 euro per year and upwards. Only doing schedules for education. Works on phones/tablets (who would want that??).
* [MIMOSA](http://www.mimosasoftware.com/) 500 euro and upwards for larger schools / add-ons, etc. Only doing scheduling for education.
* [REDIKER](http://www.rediker.com/scheduling_plus.html) unknown price, company focuses on school administration, should have good integration with their own products at least (?).
* [UNTIS](http://www.grupet.at/home_en.php) unknown price, only doing scheduling for education.
* [EMS Campus](http://www.dea.com/ProductsAndServices/Campus/Default.aspx?mi=3) unknown price, doing scheduling for all kinds of organization (not manufacturing though).
